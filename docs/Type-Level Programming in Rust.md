## **1\. Introduction**

Type-level programming in Rust represents a paradigm where computations and logic are performed within the type system at compile time, rather than during the execution of the program. This advanced technique leverages Rust's powerful type system, particularly its generics and traits, to achieve enhanced type safety, enable zero-cost abstractions [^fn1], and potentially improve performance through compile-time optimizations.[^fn2] By shifting computation to the compilation phase, developers can catch errors earlier in the development cycle and create more expressive and robust APIs. This report aims to explore various strategies and tactics employed in Rust for type-level programming, focusing on methods to avoid conflicting type instances and the practical application of concepts such as type-level fences, choice operations, fold, unfold, and map. The report will also highlight relevant Rust libraries that facilitate these advanced programming techniques.[^fn4]

## **2\. Avoiding Conflicting Type Instances**

A crucial aspect of type-level programming in Rust, especially when working with traits and generics, is ensuring that type instances do not conflict. Rust's design incorporates mechanisms to guarantee coherence, meaning there is at most one implementation of a given trait for a given type within the entire dependency graph of a project. This is primarily enforced by the orphan rule.

### **2.1. Rust's Coherence Rules (Orphan Rule)**

The concept of coherence in Rustâ€™s trait system is paramount for maintaining type safety and predictability. Coherence ensures that when the compiler encounters a method call or a trait bound, it can unambiguously determine which implementation of the trait to use for the given type. The orphan rule [^fn5] is the cornerstone of this guarantee. It dictates that an implementation of a trait for a type is considered valid only if either the trait itself or the type being implemented is defined within the current crate. This rule effectively prevents external crates from implementing traits on types they do not own, and conversely, from implementing foreign traits on types they do own, thus eliminating the possibility of conflicting implementations arising from different parts of the dependency tree. This design choice is fundamental to Rust's commitment to zero-cost abstractions and strong compile-time checking, as it allows the compiler to make definitive decisions about type behavior without runtime overhead.[^fn1]  
Without the enforcement of the orphan rule, a scenario could arise where two different crates independently provide implementations for the same trait on the same type. This would lead to ambiguity for the Rust compiler, making it impossible to determine which implementation should be used at any given call site. Consequently, the compiler would be unable to guarantee the program's behavior, potentially leading to unexpected outcomes or runtime errors. The orphan rule resolves this issue by establishing clear ownership and locality requirements for trait implementations, thereby ensuring that for any given type and trait, there is a single, authoritative implementation that the compiler can rely upon.[^fn5]

### **2.2. Strategies for Ensuring Distinct Implementations**

While the orphan rule provides a foundational layer for preventing conflicts, developers often need to employ specific strategies to ensure distinct type instances when engaging in type-level programming. These strategies allow for the creation of specialized behaviors and logic tied to particular type-level states or properties without violating Rust's coherence rules.

#### **2.2.1. Marker Traits**

Marker traits, which are traits that do not define any methods, serve as a powerful tool for creating distinct types at the type level.[^fn6] By defining a trait without associated behavior, developers can use it purely as a marker to differentiate between types that might otherwise have the same underlying representation. Implementing a marker trait for a specific type signals a particular property or state associated with that type. This allows for providing specialized trait implementations for types that are marked with a certain trait, without conflicting with implementations for the same underlying type that do not have this marker. For instance, in scenarios involving units of measurement, one could define marker traits like Kilometer and Mile. Different implementations of a conversion trait could then be provided for a numeric type based on whether it is marked as Kilometer or Mile, thus avoiding conflicts and ensuring type-safe conversions. The use of marker traits leverages Rust's trait system to introduce semantic distinctions at the type level, enabling more precise control over type behavior.[^fn6]

#### **2.2.2. Newtype Pattern**

The newtype pattern in Rust involves wrapping an existing type within a new struct or tuple struct.[^fn7] This seemingly simple technique creates a distinct type that is considered different from the underlying type by the Rust compiler. Consequently, the newtype can have its own set of trait implementations without any risk of conflicting with implementations defined for the original underlying type. This pattern is particularly useful when developers need to add specific behavior or invariants to an existing type without altering its fundamental structure or breaking compatibility. For example, if one wants to represent a specific kind of string, like an EmailAddress, they could wrap the standard String type in a new struct. This EmailAddress newtype could then implement traits related to email validation or specific formatting rules, independently of any implementations that might exist for String itself.5 The newtype pattern provides a lightweight and efficient way to achieve semantic separation and avoid type implementation conflicts.[^fn7]

#### **2.2.3. Associated Types**

Associated types, defined within traits, can play a significant role in avoiding conflicting type instances by allowing for more fine-grained control over trait implementations.[^fn6] A trait can declare one or more associated types, which are placeholders for concrete types that must be specified by implementing types. This mechanism allows different implementations of the same trait to naturally work with different related types, thus reducing the likelihood of conflicts. For instance, a trait like Container might have an associated type Item. Implementations of Container for different data structures, such as Vec and LinkedList, would specify their respective element types as the associated Item type. This inherent differentiation based on the associated type helps in maintaining coherence, as the trait implementation is implicitly tied to the specific types it is designed to work with. Furthermore, associated types can be used to create constraints that are mutually exclusive, as demonstrated in scenarios where a trait might have an associated Level type that can be either Error or Info. It becomes impossible for a single type to implement the trait with both Error and Info as its associated Level, thus naturally avoiding conflicts.[^fn8]

#### **2.2.4. Careful Trait Design**

The design of traits themselves is a critical factor in preventing unintended blanket implementations that could potentially lead to conflicts in the future.[^fn5] Blanket implementations are generic implementations of a trait that apply to all types that satisfy certain trait bounds. While powerful, overly broad or unspecific trait bounds in blanket implementations can inadvertently overlap with more specific implementations provided later, either within the same crate or in downstream crates. Therefore, it is essential to design traits with a clear understanding of their intended scope and the types they are meant to be implemented for. Traits should be specific enough to accurately capture the desired behavior without being so general that they could unintentionally apply to a wide range of types in ways that might conflict with more specialized implementations. For example, if a trait is intended for a very specific domain, its definition and the trait bounds it imposes should reflect those specific requirements, thereby minimizing the risk of unexpected or conflicting implementations arising from unrelated types.[^fn5]

## **3\. Type-Level Fences for State Management**

Type-level fences represent a powerful technique in Rust for managing the state of a system or object by encoding state transitions and constraints directly within the type system. This approach leverages Rust's strong typing to ensure that operations are only performed when the object is in a valid state, leading to more robust and less error-prone code.

### **3.1. Encoding State Machines in the Type System**

One effective method for implementing type-level fences is by representing each state of a system as a unique type.[^fn9] State transitions are then modeled as functions or methods that consume an object of one state type and return a new object of a different state type, reflecting the transition to the next state. This pattern ensures that the type of an object inherently indicates its current state, and the compiler can verify that only state-appropriate operations are performed. For instance, consider the lifecycle of a network connection. It might have states like Connecting, Connected, and Closed. Each of these states could be represented by a distinct struct. A function to establish a connection would take a Connecting type and return a Connected type. Similarly, a close operation would take a Connected type and return a Closed type. Attempting to send data on a Connecting connection, for example, would result in a compile-time error because the send method would likely be defined only for the Connected type.[^fn10] This approach leverages Rust's strong type checking to enforce state machine rules at compile time, eliminating the possibility of runtime state errors.

### **3.2. Phantom Types for Enforcing State Transitions**

Phantom types offer an elegant way to encode state information at the type level without incurring any runtime overhead.[^fn11] A phantom type is a type parameter of a struct or enum that is not actually used in any of its fields. Instead, it serves as a compile-time marker to associate the type with certain properties or states. Consider a Transformer struct [^fn11] that can be in two states: DieselTruck and OptimusPrime. These states could be represented as zero-sized structs. The Transformer struct would be defined with a phantom type parameter T, such that Transformer\<DieselTruck\> represents the initial state and Transformer\<OptimusPrime\> represents the transformed state. Methods like honk and transform would be implemented only for Transformer\<DieselTruck\>. The transform method would consume the Transformer\<DieselTruck\> and return a Transformer\<OptimusPrime\>. Conversely, a roll\_out method would be implemented only for Transformer\<OptimusPrime\>. Trying to call roll\_out on a Transformer\<DieselTruck\> or honk on a Transformer\<OptimusPrime\> would lead to a compile-time error, effectively enforcing the correct sequence of state transitions.[^fn11]

### **3.3. State as Zero-Sized Types**

Zero-sized structs or enums provide an efficient means of representing states at the type level.[^fn4] These types, as their name suggests, occupy no space at runtime. Their sole purpose is to exist as distinct types that can be used as type parameters or associated types to signify a particular state or property. For example, in the context of Peano number encoding [^fn4], the number zero can be represented by a zero-sized struct Zero, and the successor of a number N can be represented by a struct Succ\<N\>, also potentially zero-sized if N itself is zero-sized. These types are used purely at compile time to perform type-level arithmetic and comparisons. The compiler optimizes away any runtime representation of these types, ensuring that their use does not introduce any performance overhead. This makes zero-sized types ideal for encoding state information that is relevant only during compilation for type checking and logic enforcement.

### **3.4. Example: Type-Level Session Types**

Session types offer a compelling real-world application of type-level fences for ensuring the correctness of communication protocols in concurrent and distributed systems.[^fn10] In this paradigm, the type of a communication channel encodes the sequence of allowed operations, such as sending or receiving specific types of data. The state of the communication is thus represented by the channel's type. For instance, a channel that is expected to first send an integer and then receive a string would have a different type than a channel that should first receive a boolean and then send a floating-point number. Operations like send and recv are designed to consume the channel in its current state (type) and return a new channel with an updated type that reflects the progression of the protocol. Consider a simple protocol where a server sends a "ping" and then receives a "pong".9 The initial state of the server's channel might be CanSendPing. After the send operation, the channel's type would change to CanReceivePong. Once the "pong" is received, the channel might transition to a Closed state or back to CanSendPing for another round, depending on the protocol's definition. Attempting to perform an operation that is not allowed in the current state, such as trying to receive a "pong" before sending a "ping", would result in a compile-time type error. This ensures that the communication adheres to the defined protocol, preventing common concurrency errors like race conditions or deadlocks arising from incorrect communication sequences.9

## **4\. Implementing Type-Level Choice Operations**

Type-level choice operations enable the selection of types or behavior at compile time based on certain conditions. Rust's type system provides several mechanisms to implement this, allowing for highly adaptable and configurable code.

### **4.1. Conditional Types with Traits and Associated Types**

Traits with associated types provide a fundamental way to implement type-level if-else logic in Rust.16 A trait can be defined to take a type parameter that represents a condition (often a boolean-like type). Based on this condition, an associated Output type can be defined differently for various implementations of the trait. For example, one could define a trait Select\<Condition\> with an associated type Output. Implementations for different Condition types (e.g., a custom True and False zero-sized struct) could then specify different Output types. If Condition is True, Output might be one type, and if Condition is False, Output might be another. This allows for selecting a type at compile time based on the type-level condition. The snippet 16 illustrates this concept with an Either type and an If trait, where the Output type of If\<Condition\> depends on whether Condition is B1 (true) or B0 (false). This mechanism is a cornerstone of many type-level programming techniques in Rust, enabling the creation of logic that operates on types themselves.

### **4.2. The condtype Crate**

The condtype crate 17 offers a dedicated and convenient solution for implementing conditional typing in Rust based on boolean constants known at compile time. It provides the CondType\<B, T1, T2\> type, which resolves to either T1 or T2 depending on the boolean generic constant B. If B is true, CondType is an alias for T1; otherwise, it's an alias for T2. The crate also provides the condval\! macro, which allows for choosing differently-typed values without explicitly specifying the types, as the type is inferred based on the condition. For instance, condval\!(if true { "hello" } else { 42 }) will have the type \&str, while condval\!(if false { "hello" } else { 42 }) will have the type i32. The condval\! macro also supports if let pattern matching for more complex conditional logic.18 While condtype is powerful for conditions based on boolean constants, it currently has limitations in directly supporting generic constants due to ongoing developments in Rust's trait system.17 The following table provides a comparison between condtype and the standard library's cfg\_if\! macro for conditional compilation:

| Feature | condtype | cfg\_if\! |
| :---- | :---- | :---- |
| **Purpose** | Conditional typing based on boolean constants | Conditional compilation based on features/targets |
| **Mechanism** | Generic type and macro | \#\[cfg\] attributes and macro |
| **Type Safety** | Type-safe selection of types and values | Primarily controls code inclusion/exclusion |
| **Runtime Cost** | Zero runtime overhead | Zero runtime overhead |
| **Limitations** | Limited support for generic constants | Primarily for build-time configuration |

### **4.3. Matching on Types with tyrade**

The tyrade crate [^fn15] introduces a pure functional language for type-level programming in Rust, providing a more expressive domain-specific language (DSL) for complex type manipulations. One of the key features of tyrade is its support for match expressions at the type level. This allows developers to perform pattern matching on types, similar to how match works with values in standard Rust code. The TAdd example in the tyrade documentation [^fn15] demonstrates this by defining a type-level function that adds two Peano numerals. The function uses a match expression to determine the result based on the structure of the input types. If the first number is zero (Z), the result is the second number. If the first number is a successor (S(N3)), the function recursively calls itself with the predecessor and the successor of the second number. tyrade then translates this high-level code into standard Rust traits and implementations that perform the type-level computation at compile time. This approach offers a more structured and readable way to define complex type-level logic, including sophisticated type-level choice operations based on pattern matching.

## **5\. Type-Level Functional Operations (Fold, Unfold, Map)**

Functional programming concepts like fold, unfold, and map can also be applied at the type level in Rust, enabling powerful compile-time manipulations of type sequences and structures.

### **5.1. Fold (Reduce) at the Type Level**

Fold, also known as reduce, is a fundamental operation in functional programming that involves combining the elements of a collection into a single value by iteratively applying a binary function. At the type level, fold operates similarly, but instead of combining values, it combines types within a type-level collection (such as an HList from the frunk crate) into a single resulting type. This is typically achieved by defining a type-level function, often represented as a trait, and applying it sequentially to the types in the collection. For example, one might want to define a type-level function that calculates the sum of a sequence of type-level numbers (like those provided by the typenum crate). Using frunk's HList, which allows for heterogeneous lists where each element's type is known at compile time, a fold operation could iterate through the HList, applying the type-level addition function at each step, ultimately resulting in a single type representing the sum.[^fn23] The frunk crate provides methods like foldr on HList that facilitate this type-level reduction, enabling the compile-time accumulation or transformation of type sequences into a final type.

### **5.2. Unfold (Generate) at the Type Level**

Unfold is the inverse of fold; it involves generating a sequence of values from an initial seed by repeatedly applying a function. At the type level, unfold would similarly involve generating a sequence of types starting from an initial type by repeatedly applying a type-level function. However, implementing a pure type-level unfold in Rust presents challenges, primarily due to the need for a clear termination condition within the type system to prevent infinite type recursion during compilation. While a direct, general-purpose type-level unfold might be complex, the concept of generating type sequences based on a starting point can be simulated through creative uses of Rust's type system. For instance, one could use recursive traits or associated types with a defined maximum recursion depth to generate a type-level list or sequence. The unfold crate [^fn24] provides a value-level implementation of unfold, which takes a function and an initial value to produce an endless iterator. While not directly type-level, it illustrates the general concept of generating sequences from a starting point. Simulating a type-level equivalent might involve a trait where an associated type represents the next element in the sequence, with the implementation recursively referring to itself until a base case is reached.

### **5.3. Map at the Type Level**

Map is another fundamental functional programming operation that involves applying a function to each element of a collection to produce a new collection containing the transformed elements. At the type level, map operates on a collection of types (like frunk's HList) and applies a type-level function to each type, resulting in a new collection of transformed types. The frunk crate provides a map function for HList that enables this type-level transformation.[^fn23] This function takes an HList of type-level functions (often represented as closures with type annotations) as an argument. Each function in the mapping HList corresponds to the type at the same position in the original HList and defines how that type should be transformed. The result of the map operation is a new HList where each type has been transformed according to the corresponding type-level function. This allows for powerful compile-time transformations of type sequences, such as converting all numeric types in an HList to their string representations or applying other type-level modifications. The operation is resolved at compile time, ensuring type safety and zero runtime overhead.

## **6\. Case Studies with Popular Crates**

Several popular Rust crates extensively utilize type-level programming techniques to provide powerful and type-safe abstractions. Examining these crates can offer practical insights into how the strategies and tactics discussed are applied in real-world scenarios.

### **6.1. Typenum**

The typenum crate [^fn16] is a prime example of a library dedicated to type-level programming in Rust. It provides type-level numbers, where numerical values are represented as distinct types. This allows for performing arithmetic and comparisons at compile time using Rust's trait system. For instance, the crate defines traits like Add, Sub, Mul, and Div, which, when implemented for these type-level numbers, produce a new type representing the result of the operation. Conflicting instances are naturally avoided because each numerical value (e.g., U1 for 1, U2 for 2, P3 for 3, N4 for \-4) is a unique type. The typenum crate also provides helper aliases like Sum\<A, B\> for \<A as Add\<B\>\>::Output, making type-level arithmetic more ergonomic. This enables developers to encode constraints related to sizes, dimensions, or other numerical properties directly in the type system, leading to compile-time verification and zero runtime cost for these computations.[^fn31]

### **6.2. Generic-Array**

The generic-array crate [^fn37] builds upon the foundation provided by typenum to offer a generic array type where the size is specified at compile time as a type parameter. It utilizes the ArrayLength trait, which is implemented for the type-level numbers from typenum, to define the size of the GenericArray struct. This allows for creating arrays with sizes known to the compiler, enabling optimizations and preventing runtime errors associated with incorrect array access. While the provided snippets do not explicitly showcase type-level map or fold operations, the generic-array crate includes traits like GenericSequence and FunctionalSequence, which suggest the potential for functional-style manipulations at the type level. For example, one might imagine a type-level map operation that transforms the types of the elements within a GenericArray based on some type-level function. The tight integration with typenum ensures that the size of the array is always a type-level constant, contributing to the overall type safety and performance of the library.[^fn39]

### **6.3. Frunk**

The frunk crate [^fn23] is a comprehensive library for generic functional programming in Rust, with a strong emphasis on type-level manipulations, particularly through its HList (Heterogeneous List) data structure. HList is a type-level linked list where the type of each element is part of the HList's type signature. frunk provides powerful type-level operations on HLists, including map and fold. The map operation allows applying a type-level function (represented as a closure) to each type within the HList, resulting in a new HList with the transformed types.[^fn23] Similarly, the fold operation enables combining the types in an HList into a single resulting type using a type-level accumulator function. frunk avoids conflicting instances through its structural typing approach and the distinct type-level representation of each HList structure. The ability to perform these functional operations at the type level makes frunk a valuable tool for advanced metaprogramming and for creating highly flexible and type-safe data structures and algorithms in Rust.[^fn42]

## **7\. Conclusion**

Type-level programming in Rust offers a powerful set of strategies and tactics for enhancing the safety, performance, and expressiveness of code. By leveraging Rust's strong type system, developers can perform computations and enforce logic at compile time, catching errors early and enabling zero-cost abstractions. Strategies such as marker traits, the newtype pattern, and careful trait design are crucial for avoiding conflicting type instances and maintaining coherence. Type-level fences, often implemented using unique types, phantom types, and zero-sized types, provide robust mechanisms for managing state within the type system, as exemplified by type-level session types. Furthermore, type-level choice operations, facilitated by traits with associated types and crates like condtype and tyrade, allow for selecting types and behaviors at compile time based on specific conditions. Finally, functional programming concepts like fold, unfold, and map can be applied at the type level, particularly with libraries like frunk, enabling sophisticated compile-time manipulations of type sequences.  
The case studies of typenum, generic-array, and frunk demonstrate the practical application and power of these techniques in creating real-world Rust libraries. Developers are encouraged to explore these crates and the underlying concepts to leverage type-level programming in their own projects. While incredibly powerful, it is important to note that type-level programming can sometimes lead to increased compile times and code complexity, so its application should be considered judiciously based on the specific requirements and trade-offs of the project.[^fn2]

## Works cited

[^fn1]: do you guys prefer functional programming style when using rust? \- Reddit, accessed on May 16, 2025, [https://www.reddit.com/r/rust/comments/tv8spd/do\_you\_guys\_prefer\_functional\_programming\_style/](https://www.reddit.com/r/rust/comments/tv8spd/do_you_guys_prefer_functional_programming_style/)  
[^fn2]: Rust Generics Made Simple \- DEV Community, accessed on May 16, 2025, [https://dev.to/leapcell/rust-generics-made-simple-5b79](https://dev.to/leapcell/rust-generics-made-simple-5b79)  
[^fn3]: Generics and Compile-Time in Rust \- TiDB, accessed on May 16, 2025, [https://www.pingcap.com/blog/generics-and-compile-time-in-rust/](https://www.pingcap.com/blog/generics-and-compile-time-in-rust/)  
[^fn4]: Type-level Bubble Sort in Rust: Part 1 \- DEV Community, accessed on May 16, 2025, [https://dev.to/thedenisnikulin/type-level-bubble-sort-in-rust-part-1-3mcb](https://dev.to/thedenisnikulin/type-level-bubble-sort-in-rust-part-1-3mcb)  
[^fn5]: How to avoid conflict with blanket trait impl? \- Rust Users Forum, accessed on May 16, 2025, [https://users.rust-lang.org/t/how-to-avoid-conflict-with-blanket-trait-impl/21244](https://users.rust-lang.org/t/how-to-avoid-conflict-with-blanket-trait-impl/21244)  
[^fn6]: Mutually Exclusive Traits in Rust â€“ Geo's Notepad \- GitHub Pages, accessed on May 16, 2025, [https://geo-ant.github.io/blog/2021/mutually-exclusive-traits-rust/](https://geo-ant.github.io/blog/2021/mutually-exclusive-traits-rust/)  
[^fn7]: Advanced Types \- The Rust Programming Language, accessed on May 16, 2025, [https://doc.rust-lang.org/book/ch20-03-advanced-types.html](https://doc.rust-lang.org/book/ch20-03-advanced-types.html)  
[^fn8]: Why do my trait implementations conflict when they constraint to different associated types?, accessed on May 16, 2025, [https://stackoverflow.com/questions/69538204/why-do-my-trait-implementations-conflict-when-they-constraint-to-different-assoc](https://stackoverflow.com/questions/69538204/why-do-my-trait-implementations-conflict-when-they-constraint-to-different-assoc)  
[^fn9]: Type-Level Programming in Rust \- Hacker News, accessed on May 16, 2025, [https://news.ycombinator.com/item?id=24687685](https://news.ycombinator.com/item?id=24687685)  
[^fn10]: Type-level Programming in Rust \- Will Crichton, accessed on May 16, 2025, [https://willcrichton.net/notes/type-level-programming/](https://willcrichton.net/notes/type-level-programming/)  
[^fn11]: Phantom Types in Rust \- benashby.com, accessed on May 16, 2025, [https://www.benashby.com/phantom-types-in-rust/](https://www.benashby.com/phantom-types-in-rust/)  
[^fn12]: Phantom type parameters \- Rust By Example, accessed on May 16, 2025, [https://doc.rust-lang.org/rust-by-example/generics/phantom.html](https://doc.rust-lang.org/rust-by-example/generics/phantom.html)  
[^fn13]: Phantom Types in Rust \- Reddit, accessed on May 16, 2025, [https://www.reddit.com/r/rust/comments/q5r9uy/phantom\_types\_in\_rust/](https://www.reddit.com/r/rust/comments/q5r9uy/phantom_types_in_rust/)  
[^fn14]: I just discovered what \`PhantomData\` is for : r/rust \- Reddit, accessed on May 16, 2025, [https://www.reddit.com/r/rust/comments/x58yhd/i\_just\_discovered\_what\_phantomdata\_is\_for/](https://www.reddit.com/r/rust/comments/x58yhd/i_just_discovered_what_phantomdata_is_for/)  
[^fn15]: willcrichton/tyrade: A pure functional language for type ... \- GitHub, accessed on May 16, 2025, [https://github.com/willcrichton/tyrade](https://github.com/willcrichton/tyrade)  
[^fn16]: Making a type level linked list with \`typenum\` crate \- help \- Rust Users Forum, accessed on May 16, 2025, [https://users.rust-lang.org/t/making-a-type-level-linked-list-with-typenum-crate/107184](https://users.rust-lang.org/t/making-a-type-level-linked-list-with-typenum-crate/107184)  
[^fn17]: condtype \- Rust \- Docs.rs, accessed on May 16, 2025, [https://docs.rs/condtype](https://docs.rs/condtype)  
[^fn18]: condval in condtype \- Rust \- Docs.rs, accessed on May 16, 2025, [https://docs.rs/condtype/latest/condtype/macro.condval.html](https://docs.rs/condtype/latest/condtype/macro.condval.html)  
[^fn19]: condtype \- Choose Rust types at compile-time via constants \- GitHub, accessed on May 16, 2025, [https://github.com/nvzqz/condtype](https://github.com/nvzqz/condtype)  
[^fn20]: condval: Create conditionally-typed values : r/rust \- Reddit, accessed on May 16, 2025, [https://www.reddit.com/r/rust/comments/13cyg9u/condval\_create\_conditionallytyped\_values/](https://www.reddit.com/r/rust/comments/13cyg9u/condval_create_conditionallytyped_values/)  
[^fn21]: CondType: choose types via boolean conditions : r/rust \- Reddit, accessed on May 16, 2025, [https://www.reddit.com/r/rust/comments/12rvg0c/condtype\_choose\_types\_via\_boolean\_conditions/](https://www.reddit.com/r/rust/comments/12rvg0c/condtype_choose_types_via_boolean_conditions/)  
[^fn22]: jerry73204/typ: Experimental type level programming in Rust \- GitHub, accessed on May 16, 2025, [https://github.com/jerry73204/typ](https://github.com/jerry73204/typ)  
[^fn23]: lloydmeta/frunk: Funktional generic type-level programming ... \- GitHub, accessed on May 16, 2025, [https://github.com/lloydmeta/frunk](https://github.com/lloydmeta/frunk)  
[^fn24]: unfold \- Rust \- Docs.rs, accessed on May 16, 2025, [https://docs.rs/unfold](https://docs.rs/unfold)  
[^fn25]: unfold \- Rust Package Registry \- Crates.io, accessed on May 16, 2025, [https://crates.io/crates/unfold](https://crates.io/crates/unfold)  
[^fn26]: frunk \- Rust \- Docs.rs, accessed on May 16, 2025, [https://docs.rs/frunk](https://docs.rs/frunk)  
[^fn27]: Exploring Column-Oriented Data in Rust with frunk HLists \- Paul Kernfeld dot com, accessed on May 16, 2025, [https://paulkernfeld.com/2019/01/13/frunk-column.html](https://paulkernfeld.com/2019/01/13/frunk-column.html)  
[^fn28]: Problem with "frunk map()" and generic type \- help \- Rust Users Forum, accessed on May 16, 2025, [https://users.rust-lang.org/t/problem-with-frunk-map-and-generic-type/37511](https://users.rust-lang.org/t/problem-with-frunk-map-and-generic-type/37511)  
[^fn29]: typenum \- Rust, accessed on May 16, 2025, [https://fizyk20.github.io/generic-array/typenum/index.html](https://fizyk20.github.io/generic-array/typenum/index.html)  
[^fn30]: typenum \- Rust \- Docs.rs, accessed on May 16, 2025, [https://docs.rs/typenum](https://docs.rs/typenum)  
[^fn31]: typenum \- crates.io: Rust Package Registry, accessed on May 16, 2025, [https://crates.io/crates/typenum/1.2.0](https://crates.io/crates/typenum/1.2.0)  
[^fn32]: typenum \- Rust, accessed on May 16, 2025, [https://cseweb.ucsd.edu/classes/sp22/cse223B-a/tribbler/typenum/index.html](https://cseweb.ucsd.edu/classes/sp22/cse223B-a/tribbler/typenum/index.html)  
[^fn33]: typenum 1.18.0 \- Docs.rs, accessed on May 16, 2025, [https://docs.rs/crate/typenum/latest](https://docs.rs/crate/typenum/latest)  
[^fn34]: Typenum has hit 1.0.0 \- announcements \- The Rust Programming Language Forum, accessed on May 16, 2025, [https://users.rust-lang.org/t/typenum-has-hit-1-0-0/3332](https://users.rust-lang.org/t/typenum-has-hit-1-0-0/3332)  
[^fn35]: Introducing typenum: Type-level numbers in Rust evaluated at compile time. \- Reddit, accessed on May 16, 2025, [https://www.reddit.com/r/rust/comments/3pbtgb/introducing\_typenum\_typelevel\_numbers\_in\_rust/](https://www.reddit.com/r/rust/comments/3pbtgb/introducing_typenum_typelevel_numbers_in_rust/)  
[^fn36]: Making a type level type function with \`typenum\` crate \- help \- Rust Users Forum, accessed on May 16, 2025, [https://users.rust-lang.org/t/making-a-type-level-type-function-with-typenum-crate/107008](https://users.rust-lang.org/t/making-a-type-level-type-function-with-typenum-crate/107008)  
[^fn37]: GenericArray in generic\_array \- Rust \- Docs.rs, accessed on May 16, 2025, [https://docs.rs/generic-array/latest/generic\_array/struct.GenericArray.html](https://docs.rs/generic-array/latest/generic_array/struct.GenericArray.html)  
[^fn38]: generic\_array \- Rust \- GitHub Pages, accessed on May 16, 2025, [https://fizyk20.github.io/generic-array/generic\_array/](https://fizyk20.github.io/generic-array/generic_array/)  
[^fn39]: generic\_array \- Rust \- Docs.rs, accessed on May 16, 2025, [https://docs.rs/generic-array](https://docs.rs/generic-array)  
[^fn40]: generic\_array/ lib.rs \- GitHub Pages, accessed on May 16, 2025, [https://fizyk20.github.io/generic-array/src/generic\_array/lib.rs.html](https://fizyk20.github.io/generic-array/src/generic_array/lib.rs.html)  
[^fn41]: generic-array \- crates.io: Rust Package Registry, accessed on May 16, 2025, [https://crates.io/crates/generic-array/0.14.7](https://crates.io/crates/generic-array/0.14.7)  
[^fn42]: frunk \- Rust \- BeachApe., accessed on May 16, 2025, [https://beachape.com/frunk/](https://beachape.com/frunk/)  
[^fn43]: frunk \- crates.io: Rust Package Registry, accessed on May 16, 2025, [https://crates.io/crates/frunk/0.2.1](https://crates.io/crates/frunk/0.2.1)  
[^fn44]: Soft question: Significantly improve Rust compile time via minimizing Generics?, accessed on May 16, 2025, [https://users.rust-lang.org/t/soft-question-significantly-improve-rust-compile-time-via-minimizing-generics/103632](https://users.rust-lang.org/t/soft-question-significantly-improve-rust-compile-time-via-minimizing-generics/103632)
