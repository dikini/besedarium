//! Tests for projection traits
//!
//! This file contains tests to verify the behavior of projection traits
//! that generate endpoint (local) session types from global session types.

use besedarium::*;

// --- Custom Label Types for Testing ---
struct L1;
struct L2;
struct L3;
impl ProtocolLabel for L1 {}
impl ProtocolLabel for L2 {}
impl ProtocolLabel for L3 {}

// --- Custom Roles for Testing ---
struct Alice;
struct Bob;
struct Charlie;
impl Role for Alice {}
impl Role for Bob {}
impl Role for Charlie {}

// --- Role equality implementations ---
impl RoleEq<Alice> for Alice {
    type Output = True;
}
impl RoleEq<Bob> for Alice {
    type Output = False;
}
impl RoleEq<Charlie> for Alice {
    type Output = False;
}

impl RoleEq<Alice> for Bob {
    type Output = False;
}
impl RoleEq<Bob> for Bob {
    type Output = True;
}
impl RoleEq<Charlie> for Bob {
    type Output = False;
}

impl RoleEq<Alice> for Charlie {
    type Output = False;
}
impl RoleEq<Bob> for Charlie {
    type Output = False;
}
impl RoleEq<Charlie> for Charlie {
    type Output = True;
}

// --- Message Types for Testing ---
struct Message;
struct Response;

// --- IO Types for Testing ---
struct Http;

// --- Tests for ProjectRole trait ---
#[cfg(test)]
mod project_role_tests {
    use super::*;

    // Test projection of TEnd
    #[test]
    fn test_projection_of_tend() {
        // Define a TEnd protocol
        type GlobalProtocol = TEnd<Http, L1>;

        // Project onto Alice
        type AliceLocal = <() as ProjectRole<Alice, Http, GlobalProtocol>>::Out;

        // Expected: EpEnd<Http, L1, Alice> (with preserved label)
        assert_type_eq!(AliceLocal, EpEnd<Http, L1, Alice>);
    }

    // Test projection of TInteract where the role is the sender
    #[test]
    fn test_projection_of_tinteract_as_sender() {
        // Define a global protocol where Alice sends a message
        type GlobalProtocol = TInteract<Http, L1, Alice, Message, TEnd<Http, L2>>;

        // Project onto Alice
        type AliceLocal = <() as ProjectRole<Alice, Http, GlobalProtocol>>::Out;

        // Expected: EpSend<Http, L1, Alice, Message, EpEnd<Http, L2, Alice>>
        assert_type_eq!(
            AliceLocal,
            EpSend<Http, L1, Alice, Message, EpEnd<Http, L2, Alice>>
        );
    }

    // Test projection of TInteract where the role is the receiver
    #[test]
    fn test_projection_of_tinteract_as_receiver() {
        // Define a global protocol where Alice sends a message
        type GlobalProtocol = TInteract<Http, L1, Alice, Message, TEnd<Http, L2>>;

        // Project onto Bob (who isn't the sender, so is a receiver)
        type BobLocal = <() as ProjectRole<Bob, Http, GlobalProtocol>>::Out;

        // Expected: EpRecv<Http, L1, Bob, Message, EpEnd<Http, L2, Bob>>
        assert_type_eq!(
            BobLocal,
            EpRecv<Http, L1, Bob, Message, EpEnd<Http, L2, Bob>>
        );
    }

    // Test projection of a more complex protocol with multiple interactions
    #[test]
    fn test_projection_of_multiple_interactions() {
        // Define a global protocol: Alice -> Bob -> Alice
        type GlobalProtocol = TInteract<
            Http,
            L1,
            Alice,
            Message,
            TInteract<Http, L2, Bob, Response, TEnd<Http, L3>>,
        >;

        // Project onto Alice
        type AliceLocal = <() as ProjectRole<Alice, Http, GlobalProtocol>>::Out;

        // Expected: EpSend<Http, L1, Alice, Message, EpRecv<Http, L2, Alice, Response, EpEnd<Http, L3, Alice>>>
        assert_type_eq!(
            AliceLocal,
            EpSend<
                Http,
                L1,
                Alice,
                Message,
                EpRecv<Http, L2, Alice, Response, EpEnd<Http, L3, Alice>>,
            >
        );

        // Project onto Bob
        type BobLocal = <() as ProjectRole<Bob, Http, GlobalProtocol>>::Out;

        // Expected: EpRecv<Http, L1, Bob, Message, EpSend<Http, L2, Bob, Response, EpEnd<Http, L3, Bob>>>
        assert_type_eq!(
            BobLocal,
            EpRecv<
                Http,
                L1,
                Bob,
                Message,
                EpSend<Http, L2, Bob, Response, EpEnd<Http, L3, Bob>>,
            >
        );
    }

    // Test projection of a choice where both branches contain the role
    #[test]
    fn test_projection_of_choice_with_role_in_both_branches() {
        // Define left and right branches
        type LeftBranch = TInteract<Http, L2, Alice, Message, TEnd<Http, L3>>;
        type RightBranch = TInteract<Http, L2, Bob, Response, TEnd<Http, L3>>;

        // Define a choice protocol
        type GlobalProtocol = TChoice<Http, L1, LeftBranch, RightBranch>;

        // Project onto Alice
        type AliceLocal = <() as ProjectRole<Alice, Http, GlobalProtocol>>::Out;

        // Expected: EpChoice<Http, L1, Alice, EpSend<...>, EpRecv<...>>
        assert_type_eq!(
            AliceLocal,
            EpChoice<
                Http,
                L1,
                Alice,
                EpSend<Http, L2, Alice, Message, EpEnd<Http, L3, Alice>>,
                EpRecv<Http, L2, Alice, Response, EpEnd<Http, L3, Alice>>,
            >
        );
    }

    // Test projection of a choice where only one branch contains the role
    #[test]
    fn test_projection_of_choice_with_role_in_one_branch() {
        // Define left and right branches
        type LeftBranch = TInteract<Http, L2, Alice, Message, TEnd<Http, L3>>;
        type RightBranch = TInteract<Http, L2, Bob, Response, TEnd<Http, L3>>;

        // Define a choice protocol
        type GlobalProtocol = TChoice<Http, L1, LeftBranch, RightBranch>;

        // Project onto Charlie (who is only in the left branch)
        type CharlieLocal = <() as ProjectRole<Charlie, Http, GlobalProtocol>>::Out;

        // Expected: EpSkip<Http, L1, Charlie> - since Charlie isn't in either branch
        assert_type_eq!(CharlieLocal, EpSkip<Http, L1, Charlie>);
    }

    // Test projection of parallel composition
    #[test]
    fn test_projection_of_parallel() {
        // Define left and right branches
        type LeftBranch = TInteract<Http, L2, Alice, Message, TEnd<Http, L3>>;
        type RightBranch = TInteract<Http, L2, Bob, Response, TEnd<Http, L3>>;

        // Make sure the branches are disjoint
        assert_disjoint!(LeftBranch, RightBranch);

        // Define a parallel protocol with () as the proof of disjointness
        type GlobalProtocol = TPar<Http, L1, LeftBranch, RightBranch, ()>;

        // Project onto Alice
        type AliceLocal = <() as ProjectRole<Alice, Http, GlobalProtocol>>::Out;

        // Expected: EpSend<...> (since Alice is only in the left branch)
        assert_type_eq!(
            AliceLocal,
            EpSend<Http, L2, Alice, Message, EpEnd<Http, L3, Alice>>
        );
    }

    // Test parallel composition with a role in both branches
    #[test]
    fn test_parallel_with_role_in_both_branches() {
        // Define left and right branches where Charlie appears in both
        type LeftBranch = TInteract<Http, L2, Charlie, Message, TEnd<Http, L3>>;
        type RightBranch = TInteract<Http, L2, Bob, Response, TEnd<Http, L3>>;

        // This would fail to compile if we tried to create a TPar because Charlie appears in both branches
        // type GlobalProtocol = TPar<Http, L1, LeftBranch, RightBranch, ()>;
        
        // Instead, let's test projection for a legal TPar
        type SafeLeftBranch = TInteract<Http, L2, Alice, Message, TEnd<Http, L3>>;
        type SafeRightBranch = TInteract<Http, L2, Bob, Response, TEnd<Http, L3>>;
        
        // This should compile fine since the branches are disjoint
        type GlobalProtocol = TPar<Http, L1, SafeLeftBranch, SafeRightBranch, ()>;
        
        // Project onto Charlie (who isn't in either branch)
        type CharlieLocal = <() as ProjectRole<Charlie, Http, GlobalProtocol>>::Out;
        
        // Expected: EpSkip<Http, L1, Charlie>
        assert_type_eq!(CharlieLocal, EpSkip<Http, L1, Charlie>);
    }

    // Test complex example with choice, parallel, and multiple interactions
    #[test]
    fn test_complex_protocol_projection() {
        // Define some nested protocol parts
        type NestedChoice = TChoice<
            Http,
            L3,
            TInteract<Http, L2, Alice, Message, TEnd<Http, L3>>,
            TInteract<Http, L2, Bob, Response, TEnd<Http, L3>>,
        >;

        // Define a complex protocol
        type GlobalProtocol = TInteract<
            Http,
            L1,
            Alice,
            Message,
            TInteract<Http, L2, Bob, Response, NestedChoice>,
        >;

        // Project onto Alice
        type AliceLocal = <() as ProjectRole<Alice, Http, GlobalProtocol>>::Out;

        // Expected: A complex local protocol for Alice
        assert_type_eq!(
            AliceLocal,
            EpSend<
                Http,
                L1,
                Alice,
                Message,
                EpRecv<
                    Http,
                    L2,
                    Alice,
                    Response,
                    EpChoice<
                        Http,
                        L3,
                        Alice,
                        EpSend<Http, L2, Alice, Message, EpEnd<Http, L3, Alice>>,
                        EpRecv<Http, L2, Alice, Response, EpEnd<Http, L3, Alice>>,
                    >,
                >,
            >
        );
    }
}
